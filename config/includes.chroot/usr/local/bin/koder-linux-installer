#!/bin/bash

# ==============================================================================
# KODER LINUX INSTALLER — Clone-based installation
# Clones the live filesystem to disk instead of debootstrap.
# All packages and configurations from the ISO are preserved.
# ==============================================================================

set -e

export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# Cores
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

log() { echo -e "${GREEN}[INFO] $1${NC}"; }
error() { echo -e "${RED}[ERRO] $1${NC}"; exit 1; }

part_suffix() {
  local disk="$1"
  if [[ "$disk" =~ [0-9]$ ]]; then
    echo "p"
  else
    echo ""
  fi
}

# Validação de Root
if [ "$EUID" -ne 0 ]; then
  error "Este script precisa ser executado como root."
fi

# ==============================================================================
# VARIÁVEIS
# ==============================================================================
mapfile -t DISKS < <(lsblk -ndo NAME,TYPE | awk '$2=="disk"{print "/dev/"$1}')
if [ ${#DISKS[@]} -lt 1 ]; then
  error "Nenhum disco detectado via lsblk."
fi
DISK1="${DISKS[0]}"
OTHER_DISKS=("${DISKS[@]:1}")

USER_NAME="rodrigo"
USER_PASS="koder"
ROOT_PASS="koder"
HOSTNAME="note"

# Live filesystem source
LIVE_ROOTFS=""
for candidate in /run/live/rootfs/filesystem.squashfs /lib/live/mount/rootfs/filesystem.squashfs; do
  if [ -d "$(dirname "$candidate")" ]; then
    # Find the actual mounted rootfs
    LIVE_ROOTFS="/lib/live/mount/rootfs/filesystem.squashfs"
    break
  fi
done
# Fallback: use the running root filesystem
LIVE_SOURCE="/lib/live/mount/rootfs/filesystem.squashfs"
if [ -d "$LIVE_SOURCE" ]; then
  LIVE_ROOT="$LIVE_SOURCE"
else
  LIVE_ROOT="/"
fi

# ==============================================================================
# PASSO 0: PREPARAÇÃO
# ==============================================================================
log "Preparando ambiente..."
timedatectl set-ntp true >/dev/null 2>&1 || true
swapoff -a || true
umount -R /mnt 2>/dev/null || true

# Desmontagem forçada
for drive in "${DISKS[@]}"; do
    mounts=$(lsblk -n -o MOUNTPOINT "$drive" | grep -v "^$" || true)
    if [ -n "$mounts" ]; then
        for m in $mounts; do
            log "Desmontando $m..."
            umount -f "$m" || true
        done
    fi
done
sleep 1

# ==============================================================================
# PASSO 1: DETECÇÃO DE GPU
# ==============================================================================
log "Detectando hardware..."
HAS_NVIDIA=0
HAS_HYBRID=0
NVIDIA_DRIVER_PKG=""
NVIDIA_GSP_PKG=""
NVIDIA_EXTRA_PKGS=""

if lspci 2>/dev/null | grep -qi "NVIDIA"; then
  HAS_NVIDIA=1
fi
if [ "$HAS_NVIDIA" -eq 1 ] && lspci 2>/dev/null | grep -Ei "VGA|3D|Display" | grep -qi "Intel\|AMD"; then
  HAS_HYBRID=1
fi

if [ "$HAS_NVIDIA" -eq 1 ]; then
  if command -v nvidia-detect >/dev/null 2>&1; then
    NVIDIA_DRIVER_PKG="$(nvidia-detect 2>/dev/null | grep -oE 'nvidia[-a-z0-9]*-driver' | head -n1)"
  fi
  if [ -z "$NVIDIA_DRIVER_PKG" ]; then
    NVIDIA_DRIVER_PKG="nvidia-driver"
  fi
  if [ "$NVIDIA_DRIVER_PKG" = "nvidia-driver" ]; then
    NVIDIA_GSP_PKG="firmware-nvidia-gsp"
  fi
  NVIDIA_EXTRA_PKGS="nvidia-settings xserver-xorg-video-nvidia"
  if [ "$HAS_HYBRID" -eq 1 ]; then
    NVIDIA_EXTRA_PKGS="$NVIDIA_EXTRA_PKGS nvidia-prime switcheroo-control"
  fi
fi

# ==============================================================================
# PASSO 2: PARTICIONAMENTO
# ==============================================================================
log "Limpando discos (Wipe)..."
for drive in "${DISKS[@]}"; do
    wipefs --all --force "$drive" || true
    partprobe "$drive" || true
done
sleep 2

log "Criando partições..."
# Drive 1: EFI + BTRFS
parted -s "$DISK1" mklabel gpt
parted -s "$DISK1" mkpart "KODER_EFI" fat32 1MiB 513MiB
parted -s "$DISK1" set 1 esp on
parted -s "$DISK1" mkpart "KODER_ROOT_1" btrfs 513MiB 100%

# Demais drives: BTRFS
idx=2
for drive in "${OTHER_DISKS[@]}"; do
    parted -s "$drive" mklabel gpt
    parted -s "$drive" mkpart "KODER_ROOT_${idx}" btrfs 1MiB 100%
    idx=$((idx + 1))
done

for drive in "${DISKS[@]}"; do
    partprobe "$drive" || true
done
sleep 2

log "Configurando BTRFS..."
EFI_PART="${DISK1}$(part_suffix "$DISK1")1"
ROOT1_PART="${DISK1}$(part_suffix "$DISK1")2"
mkfs.fat -F32 -n KODER_EFI "$EFI_PART"
mkfs.btrfs -f -L KODER_ROOT "$ROOT1_PART"

# RAID Setup
mount "$ROOT1_PART" /mnt
if [ ${#OTHER_DISKS[@]} -gt 0 ]; then
    for drive in "${OTHER_DISKS[@]}"; do
        part="${drive}$(part_suffix "$drive")1"
        btrfs device add -f "$part" /mnt
    done
    btrfs balance start -dconvert=raid0 -mconvert=raid1 /mnt --force
else
    log "Somente um disco detectado; mantendo perfil single."
fi

# Subvolumes
btrfs subvolume create /mnt/@
btrfs subvolume create /mnt/@home

# Remontagem
umount /mnt
mount -o compress=zstd,space_cache=v2,subvol=@ "$ROOT1_PART" /mnt
mkdir -p /mnt/home
mount -o compress=zstd,space_cache=v2,subvol=@home "$ROOT1_PART" /mnt/home
mkdir -p /mnt/boot/efi
mount "$EFI_PART" /mnt/boot/efi

# ==============================================================================
# PASSO 3: CLONAR SISTEMA LIVE
# ==============================================================================
log "Clonando sistema live para o disco..."
rsync -aHAXx --info=progress2 \
    --exclude='/dev/*' \
    --exclude='/proc/*' \
    --exclude='/sys/*' \
    --exclude='/tmp/*' \
    --exclude='/run/*' \
    --exclude='/mnt/*' \
    --exclude='/media/*' \
    --exclude='/lost+found' \
    --exclude='/swapfile' \
    --exclude='/lib/live' \
    --exclude='/etc/fstab' \
    --exclude='/etc/hostname' \
    --exclude='/etc/hosts' \
    --exclude='/etc/machine-id' \
    --exclude='/var/lib/dbus/machine-id' \
    / /mnt/

# Create necessary directories
mkdir -p /mnt/{dev,proc,sys,tmp,run,mnt,media}
chmod 1777 /mnt/tmp

# ==============================================================================
# PASSO 4: CONFIGURAÇÃO DO SISTEMA INSTALADO
# ==============================================================================
log "Gerando fstab..."
genfstab -U /mnt >> /mnt/etc/fstab

log "Criando script de configuração interna..."
cat <<CHROOT_SCRIPT > /mnt/setup_internal.sh
#!/bin/bash
set -e

export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# --- Machine ID ---
systemd-machine-id-setup

# --- Hostname ---
echo "$HOSTNAME" > /etc/hostname
echo "127.0.0.1 localhost" > /etc/hosts
echo "127.0.1.1 $HOSTNAME" >> /etc/hosts

# --- Repositórios (garantir que estão completos) ---
cat <<APT > /etc/apt/sources.list
deb http://deb.debian.org/debian trixie main contrib non-free non-free-firmware
deb http://security.debian.org/debian-security trixie-security main contrib non-free non-free-firmware
deb http://deb.debian.org/debian trixie-updates main contrib non-free non-free-firmware
APT

# --- Remove live-boot packages (not needed on installed system) ---
apt-get update
apt-get remove -y --purge live-boot live-config live-config-systemd 2>/dev/null || true
apt-get autoremove -y || true

# --- NVIDIA (auto-detect) ---
HAS_NVIDIA=$HAS_NVIDIA
HAS_HYBRID=$HAS_HYBRID
NVIDIA_DRIVER_PKG="$NVIDIA_DRIVER_PKG"
NVIDIA_GSP_PKG="$NVIDIA_GSP_PKG"
NVIDIA_EXTRA_PKGS="$NVIDIA_EXTRA_PKGS"

if [ "\$HAS_NVIDIA" -eq 1 ]; then
  echo "[INFO] Adicionando repositório NVIDIA CUDA..."
  wget -qO /tmp/cuda-keyring.deb https://developer.download.nvidia.com/compute/cuda/repos/debian13/x86_64/cuda-keyring_1.1-1_all.deb
  dpkg -i /tmp/cuda-keyring.deb
  rm -f /tmp/cuda-keyring.deb
  apt-get update

  echo "[INFO] NVIDIA detectado. Instalando: \$NVIDIA_DRIVER_PKG \$NVIDIA_GSP_PKG \$NVIDIA_EXTRA_PKGS nvidia-vaapi-driver"
  apt-get install -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" \
    \$NVIDIA_DRIVER_PKG \$NVIDIA_GSP_PKG \$NVIDIA_EXTRA_PKGS nvidia-vaapi-driver

  if [ "\$HAS_HYBRID" -eq 1 ]; then
    systemctl enable switcheroo-control || true
  fi

  # VA-API NVIDIA config (will be added to user bashrc later)
  cat > /etc/profile.d/nvidia-vaapi.sh << 'VAAPI_EOF'
# VA-API NVIDIA (NVDEC via nvidia-vaapi-driver)
export LIBVA_DRIVER_NAME=nvidia
export NVD_BACKEND=direct
for _node in /dev/dri/renderD*; do
  if udevadm info "\$_node" 2>/dev/null | grep -q "ID_PATH=pci-.*:01:00.0"; then
    export NVD_GPU="\$_node"
    break
  fi
done
unset _node
VAAPI_EOF

  # NVIDIA initramfs hook
  cat > /etc/initramfs-tools/hooks/nvidia << 'NVHOOK'
#!/bin/sh
PREREQ=""
prereqs() { echo "\$PREREQ"; }
case \$1 in prereqs) prereqs; exit 0;; esac
. /usr/share/initramfs-tools/hook-functions
KVER="\${version}"
for mod in nvidia nvidia-modeset nvidia-drm nvidia-current nvidia-current-modeset nvidia-current-drm; do
    SRC="/usr/lib/modules/\${KVER}/updates/dkms/\${mod}.ko.xz"
    if [ -f "\$SRC" ]; then
        DEST="\${DESTDIR}/usr/lib/modules/\${KVER}/updates/dkms/\${mod}.ko.xz"
        mkdir -p "\$(dirname "\$DEST")"
        cp "\$SRC" "\$DEST"
    fi
done
manual_add_modules drm drm_kms_helper ttm drm_ttm_helper video wmi
mkdir -p "\${DESTDIR}/etc/modprobe.d"
for f in /etc/modprobe.d/nvidia*.conf; do
    [ -f "\$f" ] && cp "\$f" "\${DESTDIR}/etc/modprobe.d/"
done
NVHOOK
  chmod +x /etc/initramfs-tools/hooks/nvidia

  # Modules no initramfs
  for mod_name in nvidia nvidia-modeset nvidia-drm; do
    grep -qxF "\$mod_name" /etc/initramfs-tools/modules 2>/dev/null || echo "\$mod_name" >> /etc/initramfs-tools/modules
  done

  # modprobe configs
  echo "options nvidia-drm modeset=1 fbdev=1" > /etc/modprobe.d/nvidia-drm.conf
  cat > /etc/modprobe.d/nvidia.conf << 'NVMODCONF'
blacklist nouveau
options nvidia NVreg_TemporaryFilePath=/var/tmp
options nvidia NVreg_EnableS0ixPowerManagement=1
options nvidia NVreg_PreserveVideoMemoryAllocations=1
NVMODCONF

  systemctl enable nvidia-persistenced || true

  # --- NVIDIA DRM reload service (for USB-C dock displays) ---
  cat > /usr/local/bin/nvidia-drm-reload-check.sh << 'NVRELOAD'
#!/bin/bash
NVIDIA_CARD=""
for card in /sys/class/drm/card[0-9]; do
    drv="\$(readlink "\$card/device/driver" 2>/dev/null || true)"
    if echo "\$drv" | grep -q nvidia; then
        NVIDIA_CARD="\$(basename "\$card")"
        break
    fi
done
[ -z "\$NVIDIA_CARD" ] && { echo "No NVIDIA card found."; exit 0; }
need_reload=0
for sf in /sys/class/drm/\${NVIDIA_CARD}-DP-*/status; do
    [ -f "\$sf" ] || continue
    dir="\$(dirname "\$sf")"
    if [ "\$(cat "\$sf" 2>/dev/null)" = "connected" ] && \
       [ "\$(cat "\$dir/enabled" 2>/dev/null)" = "disabled" ]; then
        need_reload=1; break
    fi
done
[ "\$need_reload" = "0" ] && { echo "All NVIDIA monitors OK."; exit 0; }
echo "NVIDIA monitors connected but disabled. Full stack reload..."
systemctl stop gdm || true
sleep 1
modprobe -r nvidia-drm 2>/dev/null || true
modprobe -r nvidia-modeset 2>/dev/null || true
modprobe -r nvidia-uvm 2>/dev/null || true
modprobe -r nvidia-peermem 2>/dev/null || true
modprobe -r nvidia 2>/dev/null || true
sleep 2
modprobe nvidia
modprobe nvidia-modeset
modprobe nvidia-drm modeset=1
sleep 2
systemctl start gdm
echo "Done. NVIDIA stack reloaded and GDM restarted."
NVRELOAD
  chmod +x /usr/local/bin/nvidia-drm-reload-check.sh

  cat > /etc/systemd/system/nvidia-drm-reload.service << 'NVDRMRELOAD'
[Unit]
Description=Reload NVIDIA stack to detect USB-C dock displays
After=gdm.service
ConditionPathExists=/sys/module/nvidia_drm

[Service]
Type=oneshot
ExecStartPre=/bin/sleep 10
ExecStart=/usr/local/bin/nvidia-drm-reload-check.sh
RemainAfterExit=yes
TimeoutStartSec=120

[Install]
WantedBy=graphical.target
NVDRMRELOAD
  systemctl enable nvidia-drm-reload.service

  cat > /etc/systemd/system/nvidia-disable-d3.service << 'NVD3OFF'
[Unit]
Description=Disable NVIDIA GPU D3 runtime suspend after display detection
After=graphical.target gdm.service
Wants=graphical.target

[Service]
Type=oneshot
ExecStartPre=/bin/sleep 15
ExecStart=/bin/sh -c 'for dev in /sys/bus/pci/devices/*/; do if [ -f "\$dev/vendor" ] && [ "\$(cat "\$dev/vendor")" = "0x10de" ] && [ -f "\$dev/class" ] && echo "\$(cat "\$dev/class")" | grep -q "^0x03"; then echo on > "\$dev/power/control"; fi; done'
RemainAfterExit=yes

[Install]
WantedBy=graphical.target
NVD3OFF
  systemctl enable nvidia-disable-d3.service

  if [ "\$HAS_HYBRID" -eq 1 ]; then
    grep -qxF '__NV_PRIME_RENDER_OFFLOAD=1' /etc/environment 2>/dev/null || echo '__NV_PRIME_RENDER_OFFLOAD=1' >> /etc/environment
    grep -qxF '__GLX_VENDOR_LIBRARY_NAME=nvidia' /etc/environment 2>/dev/null || echo '__GLX_VENDOR_LIBRARY_NAME=nvidia' >> /etc/environment

    cat > /etc/udev/rules.d/61-mutter-primary-gpu.rules << 'UDEVRULE'
SUBSYSTEM=="drm", KERNEL=="card[0-9]", DRIVERS=="nvidia", TAG+="mutter-device-preferred-primary"
UDEVRULE
  fi

  echo "[INFO] NVIDIA configurado."
fi

# --- Usuários ---
echo "[INFO] Configurando usuários..."
# Remove live user if exists
userdel -r user 2>/dev/null || true

echo "root:$ROOT_PASS" | chpasswd
if ! id "$USER_NAME" &>/dev/null; then
  useradd -m -G sudo,video,render,plugdev,netdev -s /bin/bash "$USER_NAME"
fi
echo "$USER_NAME:$USER_PASS" | chpasswd
echo "$USER_NAME ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/$USER_NAME
chmod 0440 /etc/sudoers.d/$USER_NAME

# --- Autostart: fix-monitor-refresh-rates ---
if [ -f /usr/local/bin/fix-monitor-refresh-rates ]; then
  mkdir -p /home/$USER_NAME/.config/autostart
  cat > /home/$USER_NAME/.config/autostart/fix-monitor-refresh-rates.desktop << 'FIXRRDESKTOP'
[Desktop Entry]
Type=Application
Name=Fix Monitor Refresh Rates
Exec=/usr/local/bin/fix-monitor-refresh-rates
X-GNOME-Autostart-Phase=Applications
X-GNOME-Autostart-enabled=true
FIXRRDESKTOP
  chown -R $USER_NAME:$USER_NAME /home/$USER_NAME/.config
fi

# --- Claude Code (per-user) ---
echo "[INFO] Instalando Claude Code..."
su - $USER_NAME -c "curl -fsSL https://claude.ai/install.sh | bash" || true

# --- Remove installer GUI from installed system ---
rm -f /usr/share/applications/koder-linux-installer-gui.desktop
rm -f /usr/local/bin/koder-linux-installer-gui
rm -f /usr/share/polkit-1/actions/com.koder.installer.policy

# Update favorites (remove installer)
if command -v glib-compile-schemas > /dev/null 2>&1; then
  # Rewrite override without installer entry
  OVERRIDE="/usr/share/glib-2.0/schemas/90_koder-linux.gschema.override"
  if [ -f "\$OVERRIDE" ]; then
    sed -i "s/'koder-linux-installer-gui.desktop', //" "\$OVERRIDE"
    glib-compile-schemas /usr/share/glib-2.0/schemas || true
  fi
fi

# --- GRUB ---
echo "[INFO] Instalando GRUB..."
grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=KODER --recheck
sed -i 's/GRUB_CMDLINE_LINUX_DEFAULT="quiet"/GRUB_CMDLINE_LINUX_DEFAULT="quiet splash nvidia-drm.modeset=1 nvidia-drm.fbdev=1"/g' /etc/default/grub
update-grub
update-initramfs -u

# --- Enable essential services ---
systemctl enable NetworkManager
systemctl enable gdm3

# --- Cleanup ---
apt-get clean
rm -rf /var/lib/apt/lists/*

echo "[INFO] Configuração interna concluída."
CHROOT_SCRIPT

chmod +x /mnt/setup_internal.sh

# ==============================================================================
# PASSO 5: CHROOT E EXECUÇÃO
# ==============================================================================
log "Executando configuração no chroot..."
mount --bind /dev /mnt/dev
mount --bind /dev/pts /mnt/dev/pts
mount --bind /proc /mnt/proc
mount --bind /sys /mnt/sys
if [ -d /sys/firmware/efi/efivars ]; then
  mount --bind /sys/firmware/efi/efivars /mnt/sys/firmware/efi/efivars
fi

chroot /mnt /setup_internal.sh

log "Limpando..."
rm -f /mnt/setup_internal.sh
rm -f /mnt/usr/local/bin/koder-linux-installer

umount -R /mnt
log "Instalação Finalizada!"
